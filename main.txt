import telebot
from telebot import types
import random
import time
import threading
import datetime
import logging
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
import psycopg2
from psycopg2 import pool, OperationalError
import socket
import ssl
import os
from flask import Flask, request
from config import TOKEN, ADMIN_ID, PAYMENT_NUMBER, CHANNEL_ID, PAYMENT_ALERTS_CHANNEL, SUBSCRIBE_CHANNEL_ID, DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD
from apscheduler.schedulers.background import BackgroundScheduler
from datetime import timezone, timedelta

ssl._create_default_https_context = ssl._create_unverified_context
socket.setdefaulttimeout(30)

logging.basicConfig(
    filename='bot_errors.log',
    level=logging.ERROR,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
error_logger = logging.getLogger('error_logger')

postgreSQL_pool = None

def init_db_pool():
    global postgreSQL_pool
    try:
        postgreSQL_pool = psycopg2.pool.ThreadedConnectionPool(
            minconn=1,
            maxconn=10,
            user=DB_USER,
            password=DB_PASSWORD,
            host=DB_HOST,
            port=DB_PORT,
            database=DB_NAME,
            sslmode='disable',
            connect_timeout=5,
            keepalives=1,
            keepalives_idle=30,
            keepalives_interval=10,
            keepalives_count=5
        )
        error_logger.info("Database connection pool created successfully")
    except OperationalError as e:
        error_logger.error(f"Failed to create connection pool: {e}")
        raise
    except Exception as e:
        error_logger.exception("Unexpected error in database connection")

def get_db_connection():
    global postgreSQL_pool
    
    if not postgreSQL_pool:
        init_db_pool()
    
    attempts = 0
    max_attempts = 3
    wait_time = 2
    
    while attempts < max_attempts:
        try:
            return postgreSQL_pool.getconn()
        except OperationalError:
            error_logger.error(f"Connection error (Attempt {attempts+1})")
            time.sleep(wait_time)
            attempts += 1
            wait_time *= 2
        except Exception as e:
            error_logger.exception(f"Unexpected error getting connection")
            attempts += 1
    
    raise OperationalError("Failed to connect to database after multiple attempts")

try:
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT 1")
    cursor.close()
    postgreSQL_pool.putconn(conn)
    error_logger.info("Database connection test successful")
except Exception as e:
    error_logger.exception("‚ùå Connection test failed")
    raise

logging.basicConfig(
    filename='bot.log',
    level=logging.WARNING,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

bot = telebot.TeleBot(TOKEN)
executor = ThreadPoolExecutor(max_workers=5)

RATE_LIMIT = 10
RATE_LIMIT_PERIOD = 10
user_request_times = defaultdict(list)

def check_rate_limit(user_id):
    now = time.time()
    user_request_times[user_id] = [
        t for t in user_request_times[user_id] 
        if now - t < RATE_LIMIT_PERIOD
    ]
    
    if len(user_request_times[user_id]) >= RATE_LIMIT:
        return False
        
    user_request_times[user_id].append(now)
    return True

bot_commands = [
    telebot.types.BotCommand("start", "Start using the bot and verify subscription"),
    telebot.types.BotCommand("admin", "Admin dashboard (admins only)"),
    telebot.types.BotCommand("stats", "Show bot statistics"),
    telebot.types.BotCommand("mytickets", "Show my tickets"),
    telebot.types.BotCommand("howto", "How the bot works"),
    telebot.types.BotCommand("faq", "Frequently asked questions"),
    telebot.types.BotCommand("pending", "Pending requests"),
    telebot.types.BotCommand("share", "Share the bot with friends"),
    telebot.types.BotCommand("winners", "Winners list"),
    telebot.types.BotCommand("support", "Contact support")
]
bot.set_my_commands(bot_commands)

conn = get_db_connection()
try:
    with conn.cursor() as cursor:
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS tickets (
            id SERIAL PRIMARY KEY,
            user_id INTEGER,
            username TEXT,
            ticket_number TEXT,
            purchase_date TEXT,
            ticket_type TEXT,
            is_winner INTEGER DEFAULT 0,
            receipt_number TEXT
        )
        """)

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS pending_requests (
            id SERIAL PRIMARY KEY,
            user_id INTEGER,
            ticket_type TEXT,
            payment_method TEXT,
            request_time TEXT,
            receipt_number TEXT,
            status TEXT DEFAULT 'pending',
            quantity INTEGER DEFAULT 1
        )
        """)

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS winners (
            id SERIAL PRIMARY KEY,
            user_id INTEGER,
            username TEXT,
            ticket_number TEXT,
            purchase_date TEXT,
            ticket_type TEXT,
            win_date TEXT,
            prize_amount INTEGER
        )
        """)

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS settings (
            key TEXT PRIMARY KEY,
            value TEXT
        )
        """)

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS audit_log (
            id SERIAL PRIMARY KEY,
            admin_id INTEGER,
            action TEXT,
            target_id INTEGER,
            details TEXT,
            timestamp TEXT
        )
        """)

        cursor.execute("CREATE INDEX IF NOT EXISTS idx_tickets_user_id ON tickets (user_id)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_tickets_ticket_type ON tickets (ticket_type)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_pending_requests_user_id ON pending_requests (user_id)")
        cursor.execute("CREATE INDEX IF NOT EXISTS idx_pending_requests_status ON pending_requests (status)")
        
        cursor.execute("INSERT INTO settings (key, value) VALUES ('daily_prize', '5000') ON CONFLICT (key) DO NOTHING")
        cursor.execute("INSERT INTO settings (key, value) VALUES ('cumulative_prize', '0') ON CONFLICT (key) DO NOTHING")
        cursor.execute("INSERT INTO settings (key, value) VALUES ('admin_alerts_enabled', '1') ON CONFLICT (key) DO NOTHING")
        conn.commit()
        error_logger.info("Tables created successfully")
except Exception as e:
    error_logger.exception("Error creating tables")
finally:
    postgreSQL_pool.putconn(conn)

db_lock = threading.RLock()
subscription_cache = {}
CACHE_EXPIRY = 300

user_data = {}
scheduler = BackgroundScheduler(timezone="Asia/Damascus")
scheduler.start()

def get_emoji_time(sec):
    minutes = sec // 60
    seconds = sec % 60
    time_str = f"{minutes:02d}:{seconds:02d}"
    
    mapping = {
        '0': '0Ô∏è‚É£',
        '1': '1Ô∏è‚É£',
        '2': '2Ô∏è‚É£',
        '3': '3Ô∏è‚É£',
        '4': '4Ô∏è‚É£',
        '5': '5Ô∏è‚É£',
        '6': '6Ô∏è‚É£',
        '7': '7Ô∏è‚É£',
        '8': '8Ô∏è‚É£',
        '9': '9Ô∏è‚É£',
        ':': '‚è±Ô∏è'
    }
    emoji_str = ''.join(mapping[char] for char in time_str)
    return "‚è±Ô∏è " + emoji_str

def is_user_subscribed(user_id):
    try:
        chat_member = bot.get_chat_member(SUBSCRIBE_CHANNEL_ID, user_id)
        return chat_member.status in ['member', 'administrator', 'creator']
    except telebot.apihelper.ApiTelegramException as e:
        if e.error_code == 400:
            return False
        error_logger.error(f"Subscription check error: {e}")
        return False
    except Exception as e:
        error_logger.exception("Unexpected error in subscription check")
        return False

def subscription_markup():
    markup = types.InlineKeyboardMarkup()
    btn = types.InlineKeyboardButton("üì¢ Subscribe to Channel", url="https://t.me/MasterSyria1")
    markup.add(btn)
    markup.add(types.InlineKeyboardButton("‚úÖ Confirm Subscription", callback_data="check_sub"))
    return markup

def get_local_time():
    return datetime.datetime.now(timezone.utc).astimezone(timezone(timedelta(hours=3))).replace(tzinfo=None)

def clean_old_data():
    try:
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                old_date = (datetime.datetime.now() - datetime.timedelta(days=30)).strftime("%Y-%m-%d")
                cursor.execute("DELETE FROM pending_requests WHERE request_time::date < %s", (old_date,))
                
                old_date_audit = (datetime.datetime.now() - datetime.timedelta(days=30)).strftime("%Y-%m-%d")
                cursor.execute("DELETE FROM audit_log WHERE timestamp::date < %s", (old_date_audit,))
                
                old_winners = (datetime.datetime.now() - datetime.timedelta(days=365)).strftime("%Y-%m-%d")
                cursor.execute("DELETE FROM winners WHERE win_date::date < %s", (old_winners,))
                
                conn.commit()
                
                global user_data
                current_time = time.time()
                user_data = {uid: data for uid, data in user_data.items() 
                            if current_time - data.get('timestamp', 0) < 86400}
    except Exception as e:
        error_logger.exception("Error cleaning old data")
    finally:
        postgreSQL_pool.putconn(conn)

def get_user_pending_requests_count(user_id):
    try:
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                cursor.execute("SELECT COUNT(*) FROM pending_requests WHERE user_id = %s AND status = 'pending'", (user_id,))
                result = cursor.fetchone()
                return result[0] if result else 0
    except Exception as e:
        error_logger.exception("Error counting pending requests")
        return 0
    finally:
        postgreSQL_pool.putconn(conn)

def get_setting(key):
    try:
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                cursor.execute("SELECT value FROM settings WHERE key = %s", (key,))
                result = cursor.fetchone()
                return result[0] if result else None
    except Exception as e:
        error_logger.exception(f"Error getting setting: {key}")
        return None
    finally:
        postgreSQL_pool.putconn(conn)

def update_setting(key, value):
    try:
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO settings (key, value) 
                    VALUES (%s, %s)
                    ON CONFLICT (key) DO UPDATE 
                    SET value = EXCLUDED.value
                """, (key, str(value)))
                conn.commit()
    except Exception as e:
        error_logger.exception(f"Error updating setting: {key}")
    finally:
        postgreSQL_pool.putconn(conn)

def generate_ticket_numbers(ticket_type, quantity):
    try:
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                if ticket_type == 'ŸäŸàŸÖŸä':
                    cursor.execute("SELECT ticket_number FROM tickets WHERE DATE(purchase_date) = %s", (today,))
                else:
                    start_of_week = (datetime.datetime.now() - datetime.timedelta(days=datetime.datetime.now().weekday())).strftime("%Y-%m-%d")
                    end_of_week = (datetime.datetime.now() + datetime.timedelta(days=6 - datetime.datetime.now().weekday())).strftime("%Y-%m-%d")
                    cursor.execute("SELECT ticket_number FROM tickets WHERE purchase_date::date BETWEEN %s AND %s", 
                                  (start_of_week, end_of_week))
                
                existing_numbers = {row[0] for row in cursor.fetchall()}
                new_numbers = []
                
                while len(new_numbers) < quantity:
                    num = str(random.randint(10000, 99999))
                    if num not in existing_numbers and num not in new_numbers:
                        new_numbers.append(num)
                
                return new_numbers
    except Exception as e:
        error_logger.exception("Error generating ticket numbers")
        return []
    finally:
        postgreSQL_pool.putconn(conn)

def get_user_tickets(user_id):
    try:
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                cursor.execute("SELECT id, ticket_number, ticket_type, purchase_date FROM tickets WHERE user_id = %s", (user_id,))
                return cursor.fetchall()
    except Exception as e:
        error_logger.exception("Error getting user tickets")
        return []
    finally:
        postgreSQL_pool.putconn(conn)

def get_stats():
    try:
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                cursor.execute("SELECT COUNT(DISTINCT user_id) FROM tickets")
                users = cursor.fetchone()[0] or 0
                
                current_month = datetime.datetime.now().strftime("%Y-%m")
                cursor.execute("SELECT COUNT(DISTINCT user_id) FROM tickets WHERE to_char(purchase_date::timestamp, 'YYYY-MM') = %s", (current_month,))
                monthly_users = cursor.fetchone()[0] or 0
                
                cursor.execute("SELECT COUNT(*) FROM tickets")
                tickets = cursor.fetchone()[0] or 0
                
                total_amount = tickets * 5000
                prize = int(total_amount * 0.85)
                return users, monthly_users, tickets, total_amount, prize
    except Exception as e:
        error_logger.exception("Error getting statistics")
        return 0, 0, 0, 0, 0
    finally:
        postgreSQL_pool.putconn(conn)

def get_daily_stats():
    try:
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                cursor.execute("SELECT COUNT(*) FROM tickets WHERE ticket_type = 'ŸäŸàŸÖŸä' AND purchase_date::date = %s", (today,))
                daily_tickets = cursor.fetchone()[0] or 0
                
                cursor.execute("SELECT COUNT(DISTINCT user_id) FROM tickets WHERE ticket_type = 'ŸäŸàŸÖŸä' AND purchase_date::date = %s", (today,))
                daily_users = cursor.fetchone()[0] or 0
                
                daily_prize = daily_tickets * 5000 * 0.85
                return daily_tickets, daily_users, daily_prize
    except Exception as e:
        error_logger.exception("Error getting daily statistics")
        return 0, 0, 0
    finally:
        postgreSQL_pool.putconn(conn)

def get_weekly_stats():
    try:
        now = get_local_time()
        start_of_week = now - datetime.timedelta(days=now.weekday())
        end_of_week = start_of_week + datetime.timedelta(days=6)
        
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT COUNT(*) 
                    FROM tickets 
                    WHERE ticket_type = 'ÿ£ÿ≥ÿ®ŸàÿπŸä' 
                    AND purchase_date::date BETWEEN %s AND %s
                """, (start_of_week.strftime('%Y-%m-%d'), end_of_week.strftime('%Y-%m-%d')))
                weekly_tickets = cursor.fetchone()[0] or 0
                
                cursor.execute("""
                    SELECT COUNT(DISTINCT user_id) 
                    FROM tickets 
                    WHERE ticket_type = 'ÿ£ÿ≥ÿ®ŸàÿπŸä' 
                    AND purchase_date::date BETWEEN %s AND %s
                """, (start_of_week.strftime('%Y-%m-%d'), end_of_week.strftime('%Y-%m-%d')))
                weekly_users = cursor.fetchone()[0] or 0
                
                weekly_prize = weekly_tickets * 5000 * 0.85
                return weekly_tickets, weekly_users, weekly_prize
    except Exception as e:
        error_logger.exception("Error getting weekly statistics")
        return 0, 0, 0
    finally:
        postgreSQL_pool.putconn(conn)

def get_winners():
    try:
        conn = get_db_connection()
        with db_lock:
            with conn.cursor() as cursor:
                cursor.execute("SELECT username, ticket_number, ticket_type, win_date, prize_amount FROM winners ORDER BY id DESC LIMIT 10")
                return cursor.fetchall()
    except Exception as e:
        error_logger.exception("Error getting winners")
        return []
    finally:
        postgreSQL_pool.putconn(conn)

def is_admin(user_id):
    return user_id == ADMIN_ID

def main_markup(user_id):
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    pending_count = get_user_pending_requests_count(user_id)
    pending_button = f'üßæ Pending Requests ({pending_count})' if pending_count > 0 else 'üßæ Pending Requests'
    
    buttons = [
        types.KeyboardButton('üéüÔ∏è Buy Ticket Now'),
        types.KeyboardButton('üìû Contact Support'),
        types.KeyboardButton('üìä Statistics'),
        types.KeyboardButton('üé´ My Tickets'),
        types.KeyboardButton('‚ùì How It Works'),
        types.KeyboardButton('‚ùì FAQ'),
        types.KeyboardButton(pending_button),
        types.KeyboardButton('üéØ Share with Friend'),
        types.KeyboardButton('üèÜ Winners'),
    ]
    markup.add(*buttons)
    return markup

def admin_markup():
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    markup.add(
        types.KeyboardButton('üë• User Count'),
        types.KeyboardButton('üì¢ Broadcast'),
        types.KeyboardButton('üìã Pending Requests'),
        types.KeyboardButton('üè† Main Menu')
    )
    return markup

def payment_method_markup():
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    markup.add(
        types.KeyboardButton('ÿ≥Ÿäÿ±Ÿäÿ™ŸÑ ŸÉÿßÿ¥'),
        types.KeyboardButton('ÿ¥ÿßŸÖ ŸÉÿßÿ¥'),
        types.KeyboardButton('Cancel'),
    )
    return markup

def ticket_type_markup():
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    markup.add(
        types.KeyboardButton('ŸäŸàŸÖŸä'),
        types.KeyboardButton('ÿ£ÿ≥ÿ®ŸàÿπŸä'),
        types.KeyboardButton('Cancel'),
    )
    return markup

def quantity_markup():
    markup = types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True)
    for i in range(1, 11):
        markup.add(types.KeyboardButton(str(i)))
    markup.add(types.KeyboardButton('Cancel'))
    return markup

def perform_draw(draw_type):
    try:
        now = get_local_time()
        total_seconds = 60
        
        conn = get_db_connection()
        try:
            with db_lock:
                with conn.cursor() as cursor:
                    if draw_type == "ŸäŸàŸÖŸä":
                        today_str = now.strftime("%Y-%m-%d")
                        cursor.execute("SELECT COUNT(*) FROM tickets WHERE ticket_type = %s AND DATE(purchase_date) = %s", (draw_type, today_str))
                        total_tickets = cursor.fetchone()[0]
                    else:
                        start_of_week = (now - datetime.timedelta(days=now.weekday())).strftime("%Y-%m-%d")
                        end_of_week = (now + datetime.timedelta(days=6 - now.weekday())).strftime("%Y-%m-%d")
                        cursor.execute("SELECT COUNT(*) FROM tickets WHERE ticket_type = %s AND purchase_date::date BETWEEN %s AND %s", (draw_type, start_of_week, end_of_week))
                        total_tickets = cursor.fetchone()[0]
        finally:
            postgreSQL_pool.putconn(conn)
        
        if total_tickets == 0:
            bot.send_message(CHANNEL_ID, f"‚ö†Ô∏è No tickets for {draw_type} draw today")
            return "‚ö†Ô∏è No tickets for draw"
        
        offset = random.randint(0, total_tickets - 1)
        conn = get_db_connection()
        try:
            with db_lock:
                with conn.cursor() as cursor:
                    if draw_type == "ŸäŸàŸÖŸä":
                        cursor.execute("""
                            SELECT id, user_id, username, ticket_number, purchase_date 
                            FROM tickets 
                            WHERE ticket_type = %s AND DATE(purchase_date) = %s
                            OFFSET %s LIMIT 1
                        """, (draw_type, today_str, offset))
                    else:
                        cursor.execute("""
                            SELECT id, user_id, username, ticket_number, purchase_date 
                            FROM tickets 
                            WHERE ticket_type = %s AND purchase_date::date BETWEEN %s AND %s
                            OFFSET %s LIMIT 1
                        """, (draw_type, start_of_week, end_of_week, offset))
                    
                    winner = cursor.fetchone()
        finally:
            postgreSQL_pool.putconn(conn)
        
        if not winner:
            bot.send_message(CHANNEL_ID, f"‚ö†Ô∏è Error selecting winner for {draw_type} draw")
            return "‚ö†Ô∏è Error selecting winner"
        
        display_type = "Daily Draw" if draw_type == "ŸäŸàŸÖŸä" else "Weekly Draw"
        
        countdown_msg = bot.send_message(
            CHANNEL_ID,
            f"üî•‚ú® Countdown for {display_type} starts now! ‚ú®üî•\n\n"
            "‚è≥ Time remaining:\n"
            "‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è\n"
            f"{get_emoji_time(60)}\n\n"
            "üü¢üü¢üü¢üü¢üü¢üü¢üü¢üü¢üü¢üü¢\n\n"
            "üèÜ Prize waiting for the lucky winner!",
            parse_mode='Markdown'
        )
        
        start_time = time.time()
        
        for sec in range(total_seconds, -1, -1):
            elapsed = time.time() - start_time
            remaining_time = max(0, total_seconds - elapsed)
            sec = int(remaining_time)
            
            if sec < 0:
                break
                
            progress = int((sec / total_seconds) * 10)
            progress_bar = "üü¢" * (10 - progress) + "‚ö™" * progress
            
            if sec <= 10:
                fire_effect = "üî•" * (11 - sec)
                text = (
                    f"{fire_effect} Final countdown! {fire_effect}\n\n"
                    f"‚è≥ Time remaining:\n"
                    f"‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è\n"
                    f"{get_emoji_time(sec)}\n\n"
                    f"{progress_bar}\n\n"
                    "üèÜ Prize waiting for the lucky winner!"
                )
            else:
                text = (
                    f"üî•‚ú® Countdown for {display_type} ‚ú®üî•\n\n"
                    f"‚è≥ Time remaining:\n"
                    f"‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è‚¨áÔ∏è\n"
                    f"{get_emoji_time(sec)}\n\n"
                    f"{progress_bar}\n\n"
                    "üèÜ Prize waiting for the lucky winner!"
                )
            
            try:
                bot.edit_message_text(
                    text,
                    chat_id=CHANNEL_ID,
                    message_id=countdown_msg.message_id,
                    parse_mode='Markdown'
                )
            except Exception as e:
                error_logger.error(f"Countdown edit error: {e}")
            
            time_to_sleep = min(1.0, remaining_time - sec)
            if time_to_sleep > 0:
                time.sleep(time_to_sleep)
        
        ticket_id, user_id, username, ticket_number, purchase_date = winner
        
        prize_amount = int(total_tickets * 5000 * 0.85)
        win_date = now.strftime("%Y-%m-%d %H:%M:%S")
        
        conn = get_db_connection()
        try:
            with db_lock:
                with conn.cursor() as cursor:
                    cursor.execute("""
                        INSERT INTO winners (user_id, username, ticket_number, purchase_date, ticket_type, win_date, prize_amount)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (user_id, username, ticket_number, purchase_date, draw_type, win_date, prize_amount))
                    
                    if draw_type == "ŸäŸàŸÖŸä":
                        cursor.execute("""
                            DELETE FROM tickets 
                            WHERE ticket_type = %s AND DATE(purchase_date) = %s
                        """, (draw_type, today_str))
                    else:
                        cursor.execute("""
                            DELETE FROM tickets 
                            WHERE ticket_type = %s AND purchase_date::date BETWEEN %s AND %s
                        """, (draw_type, start_of_week, end_of_week))
                    
                    conn.commit()
        finally:
            postgreSQL_pool.putconn(conn)
        
        bot_username = bot.get_me().username
        start_link = f"https://t.me/{bot_username}?start=start"
        
        winner_message = (
            f"üéâüéâüéâ Congratulations! You won the {display_type} prize! üéâüéâüéâ\n\n"
            f"‚ú® Official draw results ‚ú®\n"
            f"üèÜ Draw type: {display_type}\n"
            f"üé´ Winning ticket number: {ticket_number}\n"
            f"üí∞ Prize amount: {prize_amount:,} SYP üíµ\n"
            f"üìÖ Draw date: {now.strftime('%Y-%m-%d %H:%M')}\n\n"
            f"üéä Heartfelt congratulations on your win! We wish you more success in life.\n\n"
            f"üîî You will be contacted within 24 hours to arrange prize collection.\n\n"
            f"üí¨ For more information, contact support:\n"
            f"üëâ /start"
        )
        
        try:
            bot.send_message(
                user_id,
                winner_message,
                parse_mode='Markdown'
            )
        except Exception as e:
            error_logger.error(f"Failed to send message to winner: {e}")
        
        channel_announcement = (
            f"üéâüéâüéâ Winner announced for {display_type} prize! üéâüéâüéâ\n\n"
            f"‚ú® Official draw results ‚ú®\n"
            f"üèÜ Draw type: {display_type}\n"
            f"üéüÔ∏è Tickets entered: {total_tickets}\n"
            f"ü•á Lucky winner: @{username}\n"
            f"üé´ Winning ticket number: {ticket_number}\n"
            f"üí∞ Prize amount: {prize_amount:,} SYP üíµ\n"
            f"üìÖ Draw date: {now.strftime('%Y-%m-%d %H:%M')}\n\n"
            f"üéä Congratulations to the winner! We wish him continued success! üéÅ\n\n"
            f"üíî Didn't win this time? Don't be sad!\n"
            f"üçÄ Opportunities are still available and luck may smile on you next time!\n\n"
            f"üéØ Try your luck now and buy your ticket:\n"
            f"[üëâ Click here to start]({start_link})"
        )
        bot.send_message(CHANNEL_ID, channel_announcement, parse_mode='Markdown')
        
        return "‚úÖ Draw completed successfully"
    except Exception as e:
        error_msg = f"‚ùå Error during draw: {str(e)}"
        error_logger.exception("Draw error")
        bot.send_message(CHANNEL_ID, error_msg)
        return error_msg

scheduler.add_job(
    lambda: perform_draw("ŸäŸàŸÖŸä"),
    'cron',
    hour=12,
    minute=0,
    timezone="Asia/Damascus"
)

scheduler.add_job(
    lambda: perform_draw("ÿ£ÿ≥ÿ®ŸàÿπŸä"),
    'cron',
    day_of_week='fri',
    hour=12,
    minute=0,
    timezone="Asia/Damascus"
)

scheduler.add_job(
    clean_old_data,
    'cron',
    hour=4,
    minute=0,
    timezone="Asia/Damascus"
)

def send_payment_alert(request_id, user_id, ticket_type, payment_method, quantity):
    try:
        alert_text = (
            "‚ú®üåü‚ú® New payment request! ‚ú®üåü‚ú®\n\n"
            f"üîî New request received!\n"
            f"üÜî Request ID: `{request_id}`\n"
            f"üë§ User ID: `{user_id}`\n"
            f"üéüÔ∏è Ticket type: {ticket_type}\n"
            f"üí≥ Payment method: {payment_method}\n"
            f"üî¢ Quantity: {quantity}\n"
            f"üí∏ Total: {quantity * 5000:,} SYP\n\n"
            f"üìä Please check admin dashboard"
        )
        
        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("üìã Open Admin Panel", callback_data="open_admin_panel"))
        
        try:
            bot.send_message(
                PAYMENT_ALERTS_CHANNEL,
                alert_text,
                parse_mode='Markdown',
                reply_markup=markup
            )
        except Exception as e:
            error_logger.error(f"Failed to send payment alert: {str(e)}")
            try:
                bot.send_message(ADMIN_ID, f"‚ùå Failed to send payment alert: {str(e)}")
            except Exception as e2:
                error_logger.error(f"Failed to send admin message: {e2}")
    except Exception as e:
        error_logger.exception(f"General error sending payment alert: {e}")

def send_message_safe(user_id, message):
    try:
        bot.copy_message(user_id, message.chat.id, message.message_id)
        return True
    except Exception as e:
        error_logger.error(f"Failed to send message to {user_id}: {e}")
        return False

def ensure_subscription(user_id, chat_id):
    if not is_user_subscribed(user_id):
        friendly_reminder = (
            f"üëã Welcome to Master Bot!\n\n"
            "‚ú® To continue using the bot, please subscribe to our channel first ‚ú®\n\n"
            "üîî Benefits of subscribing:\n"
            "‚Ä¢ Be the first to know daily/weekly draw results üèÜ\n"
            "‚Ä¢ Receive exclusive notifications before draws start üîî\n"
            "‚Ä¢ Get latest bot updates and special offers üéÅ\n\n"
            "After subscribing click /check to start"
        )
        bot.send_message(
            chat_id,
            friendly_reminder,
            parse_mode='Markdown',
            reply_markup=subscription_markup()
        )
        return False
    return True

def ensure_subscription_callback(user_id, callback_id):
    if not is_user_subscribed(user_id):
        bot.answer_callback_query(callback_id, "üö´ You must subscribe to the channel first. Subscribe then click confirm subscription", show_alert=True)
        return False
    return True

@bot.message_handler(commands=['start'])
def start(message):
    try:
        if not check_rate_limit(message.from_user.id):
            bot.reply_to(message, "‚ö†Ô∏è You've exceeded the request limit. Please wait a moment.")
            return

        user = message.from_user
        
        if not ensure_subscription(user.id, message.chat.id):
            return
            
        cumulative_prize = get_setting('cumulative_prize')
        prize_text = "üéÅ Today's prize: 85% of tickets sold"
            
        welcome_text = (
            f"üéâ Welcome to Master Bot - Syria's smart lottery, {user.first_name}!\n"
            f"Test your luck every day and win great prizes üí∞\n\n"
            f"{prize_text}\n\n"
            f"üí∞ Ticket price: 5000 SYP\n"
            f"üìä Full transparency and clear results for all\n\n"
            f"üìå You can check winners and draw results via 'üèÜ Winners'\n\n"
            f"üëá Choose from menu:"
        )

        bot.send_message(message.chat.id, welcome_text, reply_markup=main_markup(user.id))
    except Exception as e:
        error_logger.exception("Start command error")
        bot.reply_to(message, "Unexpected error. Please try again later.")

@bot.message_handler(commands=['admin'])
def admin_panel(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not is_admin(message.from_user.id):
            return
        
        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        markup = types.InlineKeyboardMarkup(row_width=2)
        markup.add(
            types.InlineKeyboardButton("üéØ Daily Draw", callback_data="daily_draw"),
            types.InlineKeyboardButton("üèÜ Weekly Draw", callback_data="weekly_draw"),
            types.InlineKeyboardButton("üë• User Count", callback_data="users_count"),
            types.InlineKeyboardButton("üì¢ Broadcast", callback_data="broadcast"),
            types.InlineKeyboardButton("üìã Pending Requests", callback_data="pending_requests_admin")
        )
        bot.send_message(message.chat.id, "üéõÔ∏è Admin Dashboard", reply_markup=markup)
    except Exception as e:
        error_logger.exception("Admin panel error")

@bot.callback_query_handler(func=lambda call: call.data in ["daily_draw", "weekly_draw", "users_count", "broadcast", "pending_requests_admin"])
def handle_admin_actions(call):
    try:
        if not is_admin(call.from_user.id):
            bot.answer_callback_query(call.id, "‚õî This command is for admins only!")
            return
            
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        if call.data in ["daily_draw", "weekly_draw"]:
            bot.answer_callback_query(call.id, "Processing draw...")
            draw_type = "ŸäŸàŸÖŸä" if call.data == "daily_draw" else "ÿ£ÿ≥ÿ®ŸàÿπŸä"
            result = perform_draw(draw_type)
        elif call.data == "users_count":
            users, monthly_users, tickets, total, prize = get_stats()
            response = f"üë§ Users: {users}\nüéüÔ∏è Tickets sold: {tickets}"
            bot.answer_callback_query(call.id, response, show_alert=True)
        elif call.data == "broadcast":
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            markup.add(types.KeyboardButton('Cancel'))
            bot.send_message(
                call.message.chat.id,
                "üì§ Send the message to broadcast (or press 'Cancel' to go back):",
                reply_markup=markup
            )
            bot.register_next_step_handler(call.message, process_broadcast_message)
        elif call.data == "pending_requests_admin":
            show_pending_requests(call.message.chat.id)
    except Exception as e:
        error_logger.exception("Admin actions error")
        bot.answer_callback_query(call.id, "Error during processing")

@bot.callback_query_handler(func=lambda call: call.data == "open_admin_panel")
def handle_admin_panel(call):
    try:
        if not is_admin(call.from_user.id):
            bot.answer_callback_query(call.id, "‚õî This command is for admins only!")
            return
            
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        try:
            admin_markup = types.InlineKeyboardMarkup(row_width=2)
            admin_markup.add(
                types.InlineKeyboardButton("üéØ Daily Draw", callback_data="daily_draw"),
                types.InlineKeyboardButton("üèÜ Weekly Draw", callback_data="weekly_draw"),
                types.InlineKeyboardButton("üë• User Count", callback_data="users_count"),
                types.InlineKeyboardButton("üì¢ Broadcast", callback_data="broadcast"),
                types.InlineKeyboardButton("üìã Pending Requests", callback_data="pending_requests_admin")
            )
            bot.send_message(call.from_user.id, "üéõÔ∏è Admin Dashboard", reply_markup=admin_markup)
        except Exception as e:
            bot.answer_callback_query(call.id, f"‚ùå Failed to open dashboard: {str(e)}")
    except Exception as e:
        error_logger.exception("Admin panel open error")

def show_pending_requests(chat_id, page=0, filters=None):
    try:
        per_page = 10
        offset = page * per_page
        
        conn = get_db_connection()
        try:
            with conn.cursor() as cursor:
                query = "SELECT * FROM pending_requests WHERE 1=1"
                params = []
                
                if filters and filters.get('ticket_type'):
                    query += " AND ticket_type = %s"
                    params.append(filters['ticket_type'])
                    
                if filters and filters.get('status'):
                    query += " AND status = %s"
                    params.append(filters['status'])
                    
                if filters and filters.get('date'):
                    query += " AND request_time::date = %s"
                    params.append(filters['date'])
                
                count_query = f"SELECT COUNT(*) FROM ({query}) AS subquery"
                cursor.execute(count_query, params)
                total_count = cursor.fetchone()[0]
                
                query += " ORDER BY id ASC LIMIT %s OFFSET %s"
                params.extend([per_page, offset])
                cursor.execute(query, params)
                requests = cursor.fetchall()
        finally:
            postgreSQL_pool.putconn(conn)
        
        if not requests:
            bot.send_message(chat_id, "üéâ No pending requests!")
            return
            
        total_pages = (total_count + per_page - 1) // per_page
        
        response = f"üìã Pending requests (Page {page+1}/{total_pages})\n\n"
        for i, req in enumerate(requests, 1):
            response += f"üîπ Request #{req[0]} (Tickets: {req[7]})\n"
        
        markup = types.InlineKeyboardMarkup(row_width=3)
        
        pagination_btns = []
        if page > 0:
            pagination_btns.append(types.InlineKeyboardButton("‚¨ÖÔ∏è Previous", callback_data=f"pending_page_{page-1}"))
        if page < total_pages - 1:
            pagination_btns.append(types.InlineKeyboardButton("Next ‚û°Ô∏è", callback_data=f"pending_page_{page+1}"))
        
        if pagination_btns:
            markup.row(*pagination_btns)
        
        for req in requests:
            markup.row(
                types.InlineKeyboardButton(f"üëÅÔ∏è Details {req[0]}", callback_data=f"admin_details_{req[0]}")
            )
        
        filter_btn = types.InlineKeyboardButton("üîç Filter", callback_data="filter_requests")
        markup.add(filter_btn)
        
        alerts_enabled = get_setting('admin_alerts_enabled') == '1'
        alerts_text = "üîï Disable Alerts" if alerts_enabled else "üîî Enable Alerts"
        alerts_callback = "disable_alerts" if alerts_enabled else "enable_alerts"
        markup.add(types.InlineKeyboardButton(alerts_text, callback_data=alerts_callback))
        
        bot.send_message(chat_id, response, reply_markup=markup)
    except Exception as e:
        error_logger.exception("Pending requests display error")

@bot.callback_query_handler(func=lambda call: call.data in ['enable_alerts', 'disable_alerts'])
def toggle_alerts(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        new_value = '1' if call.data == 'enable_alerts' else '0'
        update_setting('admin_alerts_enabled', new_value)
        
        alerts_text = "Alerts enabled üîî" if new_value == '1' else "Alerts disabled üîï"
        bot.answer_callback_query(call.id, alerts_text)
        
        show_pending_requests(call.message.chat.id)
    except Exception as e:
        error_logger.exception("Alerts toggle error")

@bot.callback_query_handler(func=lambda call: call.data.startswith('admin_details_'))
def show_request_details(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        request_id = int(call.data.split('_')[2])
        
        conn = get_db_connection()
        try:
            with conn.cursor() as cursor:
                cursor.execute("SELECT * FROM pending_requests WHERE id = %s", (request_id,))
                req = cursor.fetchone()
        finally:
            postgreSQL_pool.putconn(conn)
        
        if not req:
            bot.answer_callback_query(call.id, "‚ùå Request not found")
            return
        
        details = (
            f"üìã Request details #{req[0]}\n\n"
            f"üë§ User: {req[1]}\n"
            f"üé´ Type: {req[2]}\n"
            f"üí≥ Payment: {req[3]}\n"
            f"üî¢ Quantity: {req[7]}\n"
            f"üí∏ Total: {req[7] * 5000:,} SYP\n"
            f"üïí Date: {req[4]}\n"
            f"üìå Status: {req[6]}"
        )
        
        markup = types.InlineKeyboardMarkup()
        markup.row(
            types.InlineKeyboardButton("‚úÖ Approve", callback_data=f"admin_approve_{req[0]}"),
            types.InlineKeyboardButton("‚ùå Reject", callback_data=f"admin_reject_{req[0]}"),
            types.InlineKeyboardButton("üîô Back", callback_data="pending_back")
        )
        
        try:
            if req[5]:
                bot.send_photo(
                    call.message.chat.id,
                    req[5],
                    caption=details,
                    reply_markup=markup
                )
            else:
                bot.send_message(
                    call.message.chat.id,
                    details,
                    reply_markup=markup
                )
        except:
            bot.send_message(
                call.message.chat.id,
                details + f"\n‚úèÔ∏è Receipt: {req[5]}",
                reply_markup=markup
            )
        
        bot.answer_callback_query(call.id, "Request details shown")
    except Exception as e:
        error_logger.exception("Request details error")

@bot.callback_query_handler(func=lambda call: call.data == 'pending_back')
def back_to_pending(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        show_pending_requests(call.message.chat.id)
    except Exception as e:
        error_logger.exception("Back to pending error")

@bot.callback_query_handler(func=lambda call: call.data.startswith('pending_page_'))
def handle_pending_page(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        page = int(call.data.split('_')[2])
        show_pending_requests(call.message.chat.id, page)
    except Exception as e:
        error_logger.exception("Pending page change error")

@bot.callback_query_handler(func=lambda call: call.data.startswith('admin_reject_'))
def admin_reject_request(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        request_id = int(call.data.split('_')[2])
        
        try:
            conn = get_db_connection()
            try:
                with conn.cursor() as cursor:
                    cursor.execute("SELECT * FROM pending_requests WHERE id = %s", (request_id,))
                    req = cursor.fetchone()
                    
                    if not req:
                        bot.answer_callback_query(call.id, "‚ùå Request not found")
                        return
                        
                    user_id = req[1]
                    
                    cursor.execute("DELETE FROM pending_requests WHERE id = %s", (request_id,))
                    
                    cursor.execute(
                        "INSERT INTO audit_log (admin_id, action, target_id, details, timestamp) VALUES (%s, %s, %s, %s, %s)",
                        (call.from_user.id, "reject", user_id, f"Request #{request_id}", get_local_time().strftime("%Y-%m-%d %H:%M:%S"))
                    )
                    
                    conn.commit()
            finally:
                postgreSQL_pool.putconn(conn)
            
            try:
                bot.send_message(
                    user_id,
                    f"‚ùå Sorry, your ticket purchase request was rejected.\n\n"
                    f"üîç The payment receipt you sent was not accepted.\n\n"
                    f"If you think this is a mistake, please contact support:\n"
                    f"üëâ <a href='tg://user?id={ADMIN_ID}'>Click here to contact support</a>\n\n"
                    f"Thank you for your understanding! ü§ù",
                    parse_mode='HTML',
                    reply_markup=main_markup(user_id)
                )
            except Exception as e:
                error_logger.error(f"Error sending rejection message: {e}")
            
            bot.send_message(
                call.message.chat.id,
                f"‚ùå Request #{request_id} rejected successfully!",
                reply_markup=admin_markup()
            )
            bot.answer_callback_query(call.id, f"‚ùå Request #{request_id} rejected")
        except Exception as e:
            bot.send_message(
                call.message.chat.id,
                f"‚ùå Error processing request",
                reply_markup=admin_markup()
            )
            bot.answer_callback_query(call.id, f"‚ùå Processing error")
        
        show_pending_requests(call.message.chat.id)
    except Exception as e:
        error_logger.exception("Request rejection error")

@bot.callback_query_handler(func=lambda call: call.data == 'filter_requests')
def filter_requests(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        markup = types.InlineKeyboardMarkup(row_width=2)
        
        markup.add(
            types.InlineKeyboardButton("üé´ Daily", callback_data="filter_type_ŸäŸàŸÖŸä"),
            types.InlineKeyboardButton("üìÖ Weekly", callback_data="filter_type_ÿ£ÿ≥ÿ®ŸàÿπŸä")
        )
        
        markup.add(
            types.InlineKeyboardButton("üü¢ Processing", callback_data="filter_status_processing"),
            types.InlineKeyboardButton("üî¥ Pending", callback_data="filter_status_pending")
        )
        
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        markup.add(types.InlineKeyboardButton("üìÖ Today", callback_data=f"filter_date_{today}"))
        
        markup.add(types.InlineKeyboardButton("üîé Search by ID", callback_data="search_by_id"))
        
        markup.add(types.InlineKeyboardButton("üîÑ Reset", callback_data="filter_reset"))
        
        bot.send_message(call.message.chat.id, "üîç Choose filter criteria:", reply_markup=markup)
    except Exception as e:
        error_logger.exception("Filter requests error")

@bot.callback_query_handler(func=lambda call: call.data == 'search_by_id')
def search_by_id(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        msg = bot.send_message(
            call.message.chat.id,
            "üî¢ Please send request ID to search:",
            reply_markup=types.ReplyKeyboardRemove()
        )
        bot.register_next_step_handler(msg, process_search_by_id)
    except Exception as e:
        error_logger.exception("Search by ID error")

def process_search_by_id(message):
    try:
        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        if not message.text.isdigit():
            bot.send_message(
                message.chat.id,
                "‚ö†Ô∏è Invalid request ID! Must be a number.",
                reply_markup=admin_markup()
            )
            return
        
        request_id = int(message.text)
        
        conn = get_db_connection()
        try:
            with conn.cursor() as cursor:
                cursor.execute("SELECT * FROM pending_requests WHERE id = %s", (request_id,))
                req = cursor.fetchone()
        finally:
            postgreSQL_pool.putconn(conn)
        
        if not req:
            bot.send_message(
                message.chat.id,
                f"‚ö†Ô∏è No request found with ID {request_id}",
                reply_markup=admin_markup()
            )
            return
        
        details = (
            f"üìã Request details #{req[0]}\n\n"
            f"üë§ User: {req[1]}\n"
            f"üé´ Type: {req[2]}\n"
            f"üí≥ Payment: {req[3]}\n"
            f"üî¢ Quantity: {req[7]}\n"
            f"üí∏ Total: {req[7] * 5000:,} SYP\n"
            f"üïí Date: {req[4]}\n"
            f"üìå Status: {req[6]}"
        )
        
        markup = types.InlineKeyboardMarkup()
        markup.row(
            types.InlineKeyboardButton("‚úÖ Approve", callback_data=f"admin_approve_{req[0]}"),
            types.InlineKeyboardButton("‚ùå Reject", callback_data=f"admin_reject_{req[0]}"),
            types.InlineKeyboardButton("üîô Back", callback_data="pending_back")
        )
        
        try:
            if req[5]:
                bot.send_photo(
                    message.chat.id,
                    req[5],
                    caption=details,
                    reply_markup=markup
                )
            else:
                bot.send_message(
                    message.chat.id,
                    details,
                    reply_markup=markup
                )
        except:
            bot.send_message(
                message.chat.id,
                details + f"\n‚úèÔ∏è Receipt: {req[5]}",
                reply_markup=markup
            )
    except Exception as e:
        error_logger.exception("Search by ID processing error")

@bot.callback_query_handler(func=lambda call: call.data.startswith('filter_'))
def apply_filter(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        filter_type = call.data.split('_')[1]
        filter_value = call.data.split('_')[2] if len(call.data.split('_')) > 2 else None
        
        filters = {}
        if filter_type == "type":
            filters['ticket_type'] = filter_value
        elif filter_type == "status":
            filters['status'] = filter_value
        elif filter_type == "date":
            filters['date'] = filter_value
        elif filter_type == "reset":
            filters = None
        
        show_pending_requests(call.message.chat.id, 0, filters)
    except Exception as e:
        error_logger.exception("Filter application error")

def process_broadcast_message(message):
    try:
        if not is_admin(message.from_user.id):
            return
            
        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        if message.text == 'Cancel':
            bot.send_message(message.chat.id, "Broadcast cancelled.")
            return
        
        conn = get_db_connection()
        try:
            with conn.cursor() as cursor:
                cursor.execute("SELECT DISTINCT user_id FROM tickets")
                users = cursor.fetchall()
        finally:
            postgreSQL_pool.putconn(conn)
        
        count = 0
        errors = 0
        
        futures = []
        for (uid,) in users:
            futures.append(executor.submit(send_message_safe, uid, message))
        
        for future in futures:
            if future.result():
                count += 1
            else:
                errors += 1
        
        bot.send_message(message.chat.id, f"‚úÖ Message sent to {count} users. ‚ùå Failed: {errors}", reply_markup=admin_markup())
    except Exception as e:
        error_logger.exception("Broadcast processing error")

@bot.callback_query_handler(func=lambda call: call.data == "check_sub")
def check_sub(call):
    try:
        user = call.from_user
        
        if is_user_subscribed(user.id):
            cumulative_prize = get_setting('cumulative_prize')
            prize_text = "üéÅ Today's prize: 85% of tickets sold"
            
            welcome_text = (
                f"üéâ Welcome to Master Bot - Syria's smart lottery, {user.first_name}!\n"
                f"Test your luck every day and win great prizes üí∞\n\n"
                f"{prize_text}\n\n"
                f"üí∞ Ticket price: 5000 SYP\n"
                f"üìä Full transparency and clear results for all\n\n"
                f"üìå You can check winners and draw results via 'üèÜ Winners'\n\n"
                f"üëá Choose from menu:"
            )

            bot.send_message(call.message.chat.id, welcome_text, reply_markup=main_markup(user.id))
        else:
            bot.answer_callback_query(call.id, "You haven't subscribed yet! Subscribe then click confirm subscription", show_alert=True)
    except Exception as e:
        error_logger.exception("Subscription check error")

@bot.message_handler(commands=['check'])
def check_sub_command(message):
    try:
        user = message.from_user
        
        if is_user_subscribed(user.id):
            cumulative_prize = get_setting('cumulative_prize')
            prize_text = "üéÅ Today's prize: 85% of tickets sold"
            
            welcome_text = (
                f"üéâ Welcome to Master Bot - Syria's smart lottery, {user.first_name}!\n"
                f"Test your luck every day and win great prizes üí∞\n\n"
                f"{prize_text}\n\n"
                f"üí∞ Ticket price: 5000 SYP\n"
                f"üìä Full transparency and clear results for all\n\n"
                f"üìå You can check winners and draw results via 'üèÜ Winners'\n\n"
                f"üëá Choose from menu:"
            )

            bot.send_message(message.chat.id, welcome_text, reply_markup=main_markup(user.id))
        else:
            friendly_reminder = (
                f"üëã Hello {user.first_name}!\n\n"
                "‚ú® To continue using the bot, please subscribe to our channel first ‚ú®\n\n"
                "üîî Benefits of subscribing:\n"
                "‚Ä¢ Be the first to know daily/weekly draw results üèÜ\n"
                "‚Ä¢ Receive exclusive notifications before draws start üîî\n"
                "‚Ä¢ Get latest bot updates and special offers üéÅ\n\n"
                "After subscribing click /check to start"
            )
            bot.send_message(
                message.chat.id,
                friendly_reminder,
                parse_mode='Markdown',
                reply_markup=subscription_markup()
            )
    except Exception as e:
        error_logger.exception("Check command error")

@bot.message_handler(commands=['stats', 'mytickets', 'howto', 'faq', 'pending', 'share', 'winners', 'support'])
def handle_commands(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        command = message.text.split('@')[0].split('/')[-1]
        
        if command == 'stats':
            handle_stats(message)
        elif command == 'mytickets':
            my_tickets(message)
        elif command == 'howto':
            how_it_works(message)
        elif command == 'faq':
            faq(message)
        elif command == 'pending':
            handle_user_pending_requests(message)
        elif command == 'share':
            share_bot(message)
        elif command == 'winners':
            show_winners(message)
        elif command == 'support':
            support(message)
    except Exception as e:
        error_logger.exception("Command handling error")

@bot.message_handler(func=lambda message: message.text == '‚ùì How It Works')
def how_it_works(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        explanation = (
            "üìö How the lottery bot works:\n\n"
            "1Ô∏è‚É£ Buy ticket:\n"
            "   - Choose ticket type (daily/weekly)\n"
            "   - Choose quantity (1-10)\n"
            "   - Choose payment method (Syriatel Cash/Sham Cash)\n"
            "   - Send payment receipt for verification\n\n"
            "2Ô∏è‚É£ Track tickets:\n"
            "   - Click 'My Tickets üéüÔ∏è' to view your tickets\n\n"
            "3Ô∏è‚É£ Draws and prizes:\n"
            "   - üïí Daily draw: Every day at 12 PM\n"
            "   - üïí Weekly draw: Every Friday at 12 PM\n"
            "   - üèÜ Prize: 85% of total tickets value\n\n"
            "üìå Prize calculation example:\n"
            "   - If 100 daily tickets sold:\n"
            "   - üí∞ Total amount: 100 √ó 5000 = 500,000 SYP\n"
            "   - üéÅ Prize value: 500,000 √ó 85% = 425,000 SYP\n\n"
            "4Ô∏è‚É£ Transparency:\n"
            "   - View statistics via 'Statistics üìä'\n"
            "   - View previous winners via 'Winners üèÜ'\n\n"
            "‚úÖ The bot is completely safe and transparent. Good luck! üçÄ"
        )
        bot.send_message(message.chat.id, explanation)
    except Exception as e:
        error_logger.exception("How it works error")

@bot.message_handler(func=lambda message: message.text == '‚ùì FAQ')
def faq(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        faq_text = (
            "‚ùì Frequently Asked Questions:\n\n"
            "1. Is payment safe?\n"
            "Yes, all payments go through approved systems in Syria.\n\n"
            "2. How will I know if I won?\n"
            "You'll receive an immediate notification with prize details.\n\n"
            "3. When are the draws?\n"
            "- Daily draw: 12 PM\n"
            "- Weekly draw: Friday 12 PM\n\n"
            "4. How are prizes calculated?\n"
            "Prize = 85% of total tickets sold value\n\n"
            "For more questions, contact support."
        )
        bot.send_message(message.chat.id, faq_text)
    except Exception as e:
        error_logger.exception("FAQ error")

@bot.message_handler(func=lambda message: message.text == 'üé´ My Tickets')
def my_tickets(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        user_id = message.from_user.id
        tickets = get_user_tickets(user_id)
        
        if not tickets:
            bot.send_message(user_id, "‚ö†Ô∏è You haven't bought any tickets yet!")
            return
        
        markup = types.InlineKeyboardMarkup(row_width=2)
        for ticket in tickets:
            markup.add(types.InlineKeyboardButton(
                f"üé´ {ticket[1]}",
                callback_data=f"ticket_detail_{ticket[0]}"
            ))
        
        bot.send_message(
            user_id,
            "üé´ Your purchased tickets. Select a ticket to view details:",
            reply_markup=markup
        )
    except Exception as e:
        error_logger.exception("My tickets error")

@bot.callback_query_handler(func=lambda call: call.data.startswith('ticket_detail_'))
def show_ticket_details(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        ticket_id = int(call.data.split('_')[2])
        
        conn = get_db_connection()
        try:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT ticket_number, ticket_type, purchase_date, is_winner 
                    FROM tickets 
                    WHERE id = %s
                """, (ticket_id,))
                ticket = cursor.fetchone()
        finally:
            postgreSQL_pool.putconn(conn)
        
        if not ticket:
            bot.answer_callback_query(call.id, "‚ùå Ticket not found")
            return
        
        try:
            dt = datetime.datetime.strptime(ticket[2], "%Y-%m-%d %H:%M:%S")
            formatted_date = dt.strftime("%Y-%m-%d %H:%M:%S")
        except:
            formatted_date = ticket[2]
        
        winner_status = "üü¢ Winner!" if ticket[3] else "üî¥ Not won yet"
        
        now = get_local_time()
        
        if ticket[1] == 'ŸäŸàŸÖŸä':
            next_draw = now.replace(hour=12, minute=0, second=0, microsecond=0)
            if now >= next_draw:
                next_draw += datetime.timedelta(days=1)
            time_left = next_draw - now
            hours, remainder = divmod(time_left.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            time_left_str = f"{hours} hours {minutes} minutes"
        else:
            next_draw = now.replace(hour=12, minute=0, second=0, microsecond=0)
            if now.weekday() < 4:
                days_until_friday = 4 - now.weekday()
            elif now.weekday() == 4:
                if now.time() < next_draw.time():
                    days_until_friday = 0
                else:
                    days_until_friday = 7
            else:
                days_until_friday = 4 + 7 - now.weekday()
            
            next_draw = next_draw + datetime.timedelta(days=days_until_friday)
            time_left = next_draw - now
            days = time_left.days
            hours, remainder = divmod(time_left.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            time_left_str = f"{days} days {hours} hours {minutes} minutes"
        
        details = (
            f"üé´ Ticket details:\n\n"
            f"üî¢ Number: {ticket[0]}\n"
            f"üìÖ Purchase date: {formatted_date}\n"
            f"üì¶ Type: {ticket[1]}\n"
            f"üèÜ Status: {winner_status}\n"
            f"‚è≥ Time until draw: {time_left_str}"
        )
        
        bot.send_message(call.message.chat.id, details)
        bot.answer_callback_query(call.id)
    except Exception as e:
        error_logger.exception("Ticket details error")

@bot.message_handler(func=lambda message: message.text.startswith('üßæ Pending Requests'))
def handle_user_pending_requests(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        user_id = message.from_user.id
        
        conn = get_db_connection()
        try:
            with conn.cursor() as cursor:
                cursor.execute("""
                    SELECT id, ticket_type, quantity, request_time, status 
                    FROM pending_requests 
                    WHERE user_id = %s
                    ORDER BY id ASC
                """, (user_id,))
                requests = cursor.fetchall()
        finally:
            postgreSQL_pool.putconn(conn)
        
        if not requests:
            bot.send_message(user_id, "üéâ You have no pending requests!")
            return
            
        response = "üìã Your pending requests:\n\n"
        for req in requests:
            response += (
                f"üîπ Request #{req[0]}\n"
                f"   üé´ Type: {req[1]}\n"
                f"   üî¢ Quantity: {req[2]}\n"
                f"   üïí Date: {req[3]}\n"
                f"   üìå Status: {req[4]}\n\n"
            )
            
        bot.send_message(user_id, response)
    except Exception as e:
        error_logger.exception("User pending requests error")

@bot.message_handler(func=lambda message: message.text == 'üéØ Share with Friend')
def share_bot(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        user = message.from_user
        bot_username = bot.get_me().username
        ref_link = f"https://t.me/{bot_username}?start=ref_{user.id}"
        
        share_text = (
            "üî• Try your luck in Master lottery! \n\n"
            "üé´ Buy a ticket for 5000 SYP and win daily/weekly prizes!\n"
            "üí∞ Prizes up to millions of SYP!\n\n"
            f"üëá Join now via link:\n{ref_link}"
        )
        
        bot.send_message(
            message.chat.id,
            share_text,
            reply_markup=types.InlineKeyboardMarkup().add(
                types.InlineKeyboardButton("Share Link", url=f"tg://msg?text={share_text}")
            )
        )
    except Exception as e:
        error_logger.exception("Share bot error")

@bot.message_handler(func=lambda message: message.text == 'üèÜ Winners')
def show_winners(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        winners = get_winners()
        if not winners:
            bot.reply_to(message, "No winners yet.")
            return
        
        response = "üèÜ Previous winners:\n\n"
        for i, (username, ticket_number, ticket_type, win_date, prize_amount) in enumerate(winners, 1):
            try:
                dt = datetime.datetime.strptime(win_date, "%Y-%m-%d %H:%M:%S.%f")
                formatted_date = dt.strftime("%Y-%m-%d")
            except:
                formatted_date = win_date
            
            response += (
                f"{i}. üë§ {username}\n"
                f"   üé´ Ticket number: {ticket_number}\n"
                f"   üìÖ Win date: {formatted_date}\n"
                f"   üì¶ Type: {ticket_type}\n"
                f"   üí∞ Prize: {prize_amount:,} SYP\n\n"
            )
        
        bot.reply_to(message, response)
    except Exception as e:
        error_logger.exception("Show winners error")

@bot.message_handler(func=lambda message: message.text == 'üìû Contact Support')
def support(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        support_text = (
        "üìû Welcome to Master Bot support!\n\n"
        "üë®‚Äçüíª Support team is ready to help 24/7.\n"
        "For any inquiries or issues, contact:\n\n"
        f"üëâ <a href='tg://user?id={ADMIN_ID}'>Click here to contact support</a>\n\n"
        "‚è∞ Response time: 24 hours\n"
        "‚úÖ We'll be happy to assist you!"
        )
        bot.send_message(
            message.chat.id, 
            support_text,
            parse_mode='HTML'
        )
    except Exception as e:
        error_logger.exception("Support error")

@bot.message_handler(func=lambda message: message.text == 'üìä Statistics')
def handle_stats(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        daily_tickets, daily_users, daily_prize = get_daily_stats()
        weekly_tickets, weekly_users, weekly_prize = get_weekly_stats()
        users, monthly_users, tickets, total, prize = get_stats()
        
        response = (
            f"üìä Bot Statistics\n\n"
            f"üìà Today's Statistics\n"
            f"üé´ Daily tickets: {daily_tickets}\n"
            f"üí∞ Today's prize: {daily_prize:,} SYP\n\n"
            f"üìÖ Weekly Statistics\n"
            f"üé´ Weekly tickets: {weekly_tickets}\n"
            f"üí∞ Weekly prize: {weekly_prize:,} SYP"
        )
        bot.reply_to(message, response)
    except Exception as e:
        error_logger.exception("Statistics error")

def buy_ticket_step(message):
    try:
        user_id = message.from_user.id
        
        if not ensure_subscription(user_id, message.chat.id):
            return
            
        bot.send_message(
            user_id,
            "üìù Choose ticket type:",
            reply_markup=ticket_type_markup()
        )
        bot.register_next_step_handler(message, process_ticket_type)
    except Exception as e:
        error_logger.exception("Buy ticket start error")

def process_ticket_type(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        user_id = message.from_user.id
        if message.text == 'Cancel':
            if user_id in user_data:
                del user_data[user_id]
            bot.send_message(user_id, "Operation cancelled.", reply_markup=main_markup(user_id))
            return
        
        ticket_type = message.text
        if ticket_type not in ['ŸäŸàŸÖŸä', 'ÿ£ÿ≥ÿ®ŸàÿπŸä']:
            bot.send_message(user_id, "‚ö†Ô∏è Invalid ticket type! Please choose from menu.", reply_markup=ticket_type_markup())
            bot.register_next_step_handler(message, process_ticket_type)
            return
        
        now = get_local_time()
        if now.weekday() == 4 and ticket_type == 'ŸäŸàŸÖŸä':
            bot.send_message(
                user_id,
                "‚ö†Ô∏è Sorry, daily tickets cannot be purchased on Friday.\n"
                "Please choose weekly ticket.",
                reply_markup=ticket_type_markup()
            )
            bot.register_next_step_handler(message, process_ticket_type)
            return
        
        user_data[user_id] = {'ticket_type': ticket_type, 'timestamp': time.time()}
        bot.send_message(
            user_id,
            "üî¢ Enter number of tickets to buy (1-10):",
            reply_markup=quantity_markup()
        )
        bot.register_next_step_handler(message, process_ticket_quantity)
    except Exception as e:
        error_logger.exception("Ticket type processing error")

def process_ticket_quantity(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        user_id = message.from_user.id
        if message.text == 'Cancel':
            if user_id in user_data:
                del user_data[user_id]
            bot.send_message(user_id, "Operation cancelled.", reply_markup=main_markup(user_id))
            return
        
        try:
            quantity = int(message.text)
            if quantity < 1 or quantity > 10:
                raise ValueError
        except ValueError:
            bot.send_message(
                user_id,
                "‚ö†Ô∏è Invalid number! Please enter a number between 1 and 10.",
                reply_markup=quantity_markup()
            )
            bot.register_next_step_handler(message, process_ticket_quantity)
            return
        
        user_data[user_id]['quantity'] = quantity
        bot.send_message(
            user_id,
            "üí≥ Choose payment method:",
            reply_markup=payment_method_markup()
        )
        bot.register_next_step_handler(message, process_payment_method)
    except Exception as e:
        error_logger.exception("Ticket quantity processing error")

def process_payment_method(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        user_id = message.from_user.id
        if message.text == 'Cancel':
            if user_id in user_data:
                del user_data[user_id]
            bot.send_message(user_id, "Operation cancelled.", reply_markup=main_markup(user_id))
            return
        
        payment_method = message.text
        if payment_method not in ['ÿ≥Ÿäÿ±Ÿäÿ™ŸÑ ŸÉÿßÿ¥', 'ÿ¥ÿßŸÖ ŸÉÿßÿ¥']:
            bot.send_message(user_id, "‚ö†Ô∏è Invalid payment method! Please choose from menu.", reply_markup=payment_method_markup())
            bot.register_next_step_handler(message, process_payment_method)
            return
        
        user_data[user_id]['payment_method'] = payment_method
        user_data[user_id]['timestamp'] = time.time()
        
        remove_markup = types.ReplyKeyboardRemove()
        total_amount = user_data[user_id]['quantity'] * 5000
        bot.send_message(
            user_id, 
            f"üí∏ Total: {total_amount:,} SYP",
            reply_markup=remove_markup
        )
        
        if payment_method == 'ÿ≥Ÿäÿ±Ÿäÿ™ŸÑ ŸÉÿßÿ¥':
            payment_info = PAYMENT_NUMBER
            copy_markup = types.InlineKeyboardMarkup()
            copy_markup.add(types.InlineKeyboardButton("üìã Copy Number", callback_data=f"copy_{payment_info}"))
            copy_markup.add(types.InlineKeyboardButton("‚ùå Cancel", callback_data=f"cancel_payment_{user_id}"))
            
            instructions = (
                f"üìã To buy tickets, please follow these steps:\n\n"
                f"1Ô∏è‚É£ Transfer {total_amount:,} SYP to number:\n"
                f"<code>{payment_info}</code>\n\n"
                f"2Ô∏è‚É£ Send screenshot of receipt or receipt number here\n\n"
                f"üìå Note: If your request isn't processed within 6 hours, contact support."
            )
            
            bot.send_message(
                user_id,
                instructions,
                reply_markup=copy_markup,
                parse_mode='HTML'
            )
        else:
            payment_info = "9937130045912810"
            copy_markup = types.InlineKeyboardMarkup()
            copy_markup.add(types.InlineKeyboardButton("üìã Copy Account", callback_data=f"copy_{payment_info}"))
            copy_markup.add(types.InlineKeyboardButton("‚ùå Cancel", callback_data=f"cancel_payment_{user_id}"))
            
            instructions = (
                f"üìã To buy tickets, please follow these steps:\n\n"
                f"1Ô∏è‚É£ Transfer {total_amount:,} SYP to account:\n"
                f"<code>{payment_info}</code>\n\n"
                f"2Ô∏è‚É£ Send screenshot of receipt here\n\n"
                f"üìå Note: If your request isn't processed within 6 hours, contact support."
            )
            
            bot.send_message(
                user_id,
                instructions,
                reply_markup=copy_markup,
                parse_mode='HTML'
            )
        
        bot.register_next_step_handler(message, process_payment_receipt)
    except Exception as e:
        error_logger.exception("Payment method processing error")

@bot.callback_query_handler(func=lambda call: call.data.startswith('copy_'))
def copy_number(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        number = call.data.split('_', 1)[1]
        bot.answer_callback_query(call.id, f"Copied: {number}", show_alert=True)
        bot.send_message(call.message.chat.id, f"Number: `{number}`", parse_mode='Markdown')
    except Exception as e:
        error_logger.exception("Copy number error")

@bot.callback_query_handler(func=lambda call: call.data.startswith('cancel_payment_'))
def handle_cancel_payment(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        user_id = int(call.data.split('_')[-1])
        if user_id in user_data:
            del user_data[user_id]
        bot.send_message(call.message.chat.id, "Payment process cancelled.", reply_markup=main_markup(user_id))
        bot.answer_callback_query(call.id)
    except Exception as e:
        error_logger.exception("Payment cancellation error")

def process_payment_receipt(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        user_id = message.from_user.id
        
        if user_id not in user_data:
            error_logger.warning(f"User data not found for user: {user_id}")
            bot.send_message(user_id, "Session expired. Please start over.")
            return
            
        if message.text and message.text.startswith('/'):
            error_logger.info(f"Command received during payment: {message.text}")
            del user_data[user_id]
            bot.send_message(user_id, "Operation cancelled.")
            return
        
        if message.text == 'Cancel':
            error_logger.info("Payment process cancelled by user")
            if user_id in user_data:
                del user_data[user_id]
            bot.send_message(user_id, "Operation cancelled.", reply_markup=main_markup(user_id))
            return
        
        payment_method = user_data[user_id]['payment_method']
        receipt_content = None
        
        if payment_method == 'ÿ¥ÿßŸÖ ŸÉÿßÿ¥':
            if not message.photo:
                error_logger.warning("User did not send photo for ÿ¥ÿßŸÖ ŸÉÿßÿ¥")
                bot.send_message(user_id, "‚ö†Ô∏è For ÿ¥ÿßŸÖ ŸÉÿßÿ¥, please send receipt screenshot!")
                bot.register_next_step_handler(message, process_payment_receipt)
                return
            receipt_content = message.photo[-1].file_id
            error_logger.info(f"Received ÿ¥ÿßŸÖ ŸÉÿßÿ¥ receipt (photo ID: {receipt_content})")
        
        else:
            if message.photo:
                receipt_content = message.photo[-1].file_id
                error_logger.info(f"Received ÿ≥Ÿäÿ±Ÿäÿ™ŸÑ ŸÉÿßÿ¥ receipt (photo ID: {receipt_content})")
            elif message.text and message.text.isdigit() and len(message.text) >= 12:
                receipt_content = message.text
                error_logger.info(f"Received ÿ≥Ÿäÿ±Ÿäÿ™ŸÑ ŸÉÿßÿ¥ receipt (text: {receipt_content})")
            else:
                error_logger.warning("Invalid receipt format for ÿ≥Ÿäÿ±Ÿäÿ™ŸÑ ŸÉÿßÿ¥")
                bot.send_message(user_id, "‚ö†Ô∏è Please send receipt number (12 digits) or screenshot")
                bot.register_next_step_handler(message, process_payment_receipt)
                return
        
        user_data[user_id]['receipt_number'] = receipt_content
        
        error_logger.info(f"Storing payment: user={user_id}, type={user_data[user_id]['ticket_type']}, "
                         f"method={payment_method}, qty={user_data[user_id]['quantity']}")
        
        request_time = get_local_time().strftime("%Y-%m-%d %H:%M:%S")
        
        try:
            conn = get_db_connection()
            error_logger.info("Database connection acquired")
            
            try:
                with conn.cursor() as cursor:
                    cursor.execute(
                        "INSERT INTO pending_requests (user_id, ticket_type, payment_method, request_time, receipt_number, quantity) "
                        "VALUES (%s, %s, %s, %s, %s, %s) RETURNING id",
                        (
                            user_id, 
                            user_data[user_id]['ticket_type'], 
                            payment_method, 
                            request_time, 
                            user_data[user_id]['receipt_number'], 
                            user_data[user_id]['quantity']
                        )
                    )
                    request_id = cursor.fetchone()[0]
                    conn.commit()
                    error_logger.info(f"Payment request stored successfully! ID: {request_id}")
                    
            except Exception as db_error:
                error_logger.exception("Database error during payment processing")
                try:
                    conn.rollback()
                except:
                    pass
                raise db_error
                
            finally:
                postgreSQL_pool.putconn(conn)
                error_logger.info("Database connection released")
                
        except OperationalError as oe:
            error_logger.error(f"Database connection failed: {oe}")
            bot.send_message(user_id, "Unable to connect to system. Please try later.")
            return
            
        try:
            send_payment_alert(request_id, user_id, user_data[user_id]['ticket_type'], 
                              payment_method, user_data[user_id]['quantity'])
        except Exception as alert_error:
            error_logger.exception(f"Failed to send payment alert: {alert_error}")
        
        bot.send_message(
            user_id,
            "üì¨ Payment receipt sent for review. You'll be notified of the result soon.\n"
            "üö® Requests are processed within 15 minutes - 2 hours maximum",
            reply_markup=main_markup(user_id)
        )
        
        if user_id in user_data:
            del user_data[user_id]
            error_logger.info(f"Cleared user data for: {user_id}")
        
    except Exception as e:
        error_logger.exception(f"CRITICAL ERROR in payment processing: {e}")
        try:
            bot.send_message(
                user_id, 
                "Unexpected error processing your request. Please try again or contact support.",
                reply_markup=main_markup(user_id))
        except:
            error_logger.error("Failed to send error message to user")

@bot.message_handler(func=lambda message: message.text == 'üéüÔ∏è Buy Ticket Now')
def handle_buy_ticket(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        user_id = message.from_user.id
        buy_ticket_step(message)
    except Exception as e:
        error_logger.exception("Buy ticket handling error")

@bot.message_handler(func=lambda message: message.text == 'üë• User Count' and is_admin(message.from_user.id))
def admin_users_count(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        users, monthly_users, tickets, total, prize = get_stats()
        response = f"üë§ Users: {users}\nüéüÔ∏è Tickets sold: {tickets}"
        bot.reply_to(message, response)
    except Exception as e:
        error_logger.exception("Admin user count error")

@bot.message_handler(func=lambda message: message.text == 'üì¢ Broadcast' and is_admin(message.from_user.id))
def ask_broadcast_message(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        markup.add(types.KeyboardButton('Cancel'))
        
        sent = bot.reply_to(
            message, 
            "üì§ Send the message to broadcast (or press 'Cancel' to go back):",
            reply_markup=markup
        )
        bot.register_next_step_handler(sent, process_broadcast_message)
    except Exception as e:
        error_logger.exception("Broadcast request error")

@bot.message_handler(func=lambda message: message.text == 'üìã Pending Requests' and is_admin(message.from_user.id))
def admin_pending_requests(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        show_pending_requests(message.chat.id)
    except Exception as e:
        error_logger.exception("Admin pending requests error")

@bot.message_handler(func=lambda message: message.text == 'üè† Main Menu' and is_admin(message.from_user.id))
def back_to_main_admin(message):
    try:
        if not check_rate_limit(message.from_user.id):
            return

        if not ensure_subscription(message.from_user.id, message.chat.id):
            return
            
        bot.send_message(message.chat.id, "üè† Back to main menu", reply_markup=main_markup(message.from_user.id))
    except Exception as e:
        error_logger.exception("Back to main menu error")

@bot.callback_query_handler(func=lambda call: call.data.startswith('admin_approve_'))
def admin_approve_request(call):
    try:
        if not ensure_subscription_callback(call.from_user.id, call.id):
            return
            
        request_id = int(call.data.split('_')[2])
        
        try:
            conn = get_db_connection()
            try:
                with conn.cursor() as cursor:
                    cursor.execute("SELECT * FROM pending_requests WHERE id = %s", (request_id,))
                    req = cursor.fetchone()
                    if not req:
                        bot.answer_callback_query(call.id, "‚ùå Request not found")
                        return

                    user_id = req[1]
                    ticket_type = req[2]
                    receipt_number = req[5]
                    quantity = req[7]
                    
                    try:
                        user_info = bot.get_chat(user_id)
                        username = user_info.username or user_info.first_name or ""
                    except Exception:
                        username = ""
                    
                    purchase_date = get_local_time().strftime("%Y-%m-%d %H:%M:%S")
                    
                    ticket_numbers = generate_ticket_numbers(ticket_type, quantity)
                    
                    tickets_data = [(user_id, username, num, purchase_date, ticket_type, 0, receipt_number) 
                                   for num in ticket_numbers]
                    
                    cursor.executemany(
                        "INSERT INTO tickets (user_id, username, ticket_number, purchase_date, ticket_type, is_winner, receipt_number) "
                        "VALUES (%s, %s, %s, %s, %s, %s, %s)",
                        tickets_data
                    )
                    
                    cursor.execute("DELETE FROM pending_requests WHERE id = %s", (request_id,))
                    
                    cursor.execute(
                        "INSERT INTO audit_log (admin_id, action, target_id, details, timestamp) "
                        "VALUES (%s, %s, %s, %s, %s)",
                        (call.from_user.id, "approve", user_id, f"Request #{request_id}", purchase_date)
                    )
                    
                    conn.commit()
            finally:
                postgreSQL_pool.putconn(conn)

            try:
                tickets_info = "\n".join([f"üé´ Ticket #{i+1}: {num}" for i, num in enumerate(ticket_numbers)])
                
                bot.send_message(
                    user_id,
                    f"üéâ Your request approved successfully!\n\n"
                    f"‚úÖ {quantity} tickets reserved for next {ticket_type} draw:\n"
                    f"{tickets_info}\n\n"
                    f"üìÖ Purchase date: {purchase_date}",
                    reply_markup=main_markup(user_id)
                )
            except Exception as e:
                error_logger.error(f"Error sending approval message: {e}")
                
            bot.answer_callback_query(call.id, f"‚úÖ Request #{request_id} approved")
            bot.send_message(
                call.message.chat.id,
                f"‚úÖ Request #{request_id} approved successfully!\n"
                f"üé´ Tickets added: {quantity}",
                reply_markup=admin_markup()
            )

        except Exception as e:
            error_msg = f"‚ùå Error processing request: {str(e)}"
            error_logger.exception("Approval error")
            bot.answer_callback_query(call.id, error_msg)
            bot.send_message(
                call.message.chat.id,
                error_msg,
                reply_markup=admin_markup()
            )
        
        try:
            show_pending_requests(call.message.chat.id)
        except Exception as e:
            error_logger.error(f"Error updating requests list: {e}")
    except Exception as e:
        error_logger.exception("Approval processing error")

app = Flask(__name__)

@app.route('/' + TOKEN, methods=['POST'])
def webhook():
    if request.headers.get('content-type') == 'application/json':
        json_string = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_string)
        bot.process_new_updates([update])
        return ''
    return 'Bad request', 400

@app.route('/')
def index():
    return 'Bot is running!', 200

if __name__ == '__main__':
    PORT = int(os.environ.get('PORT', 10000))
    bot.remove_webhook()
    bot.set_webhook(url='https://master-gfh3.onrender.com/' + TOKEN)
    app.run(host='0.0.0.0', port=PORT)